{
  "hash": "b1276dbf1eae43239e6e3cdc07e01562",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Rigid and Flexible Anlysis\n---\n\n\n\nThis notebook shows an example use case of pyslammer for running rigid, decoupled, and coupled sliding block analyses.\n\n*The next steps assume you've already installed pySLAMMER from PYPI. See the [quickstart guide](../quickstart.qmd) for installation instructions.*\n\nFirst, import pySLAMMER and a couple other helpful packages\n\n\n::: {#5d48ab4b .cell execution_count=1}\n``` {.python .cell-code}\nimport pyslammer as slam\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n:::\n\n\nNext define the ground motion to use in the analysis. For this example, we will use one of pySLAMMER's built in ground motions from the 1995 Kobe earthquake. This creates a ground motion object with `accel` and `dt` attributes with the acceleration array and timestep, respectively.\n\n::: {#c29d6088 .cell execution_count=2}\n``` {.python .cell-code}\nrecord_name = \"Kobe_1995_TAK-090\"\ngm = slam.sample_ground_motions()[record_name]\n```\n:::\n\n\n## Rigid block analysis\n\nA rigid block analysis requires at least two input parameters:\n\n-   `ground_motion` - the input ground motion object, which contains the name, acceleration signal, and timestep\n-   `ky` - the slope's yield acceleration (in units of g)\n\nThese parameters are stored in a dictionary (`rigid_inputs`) and used as kwarg input to the `RigidAnalysis` method.\n\n::: {#83dbe08f .cell execution_count=3}\n``` {.python .cell-code}\nrigid_inputs = {\n    \"ground_motion\": gm,\n    \"ky\": 0.2\n}\n\nrigid_result = slam.RigidAnalysis(**rigid_inputs)\n```\n:::\n\n\n::: callout-note\n## Note\n\nPassing the input variables to `slam.RigidAnalysis` as a dictionary isn't necessary, it's just a convenient way to package groups of input variables. The following line would have produced the same result as the previous cell:\n\n`rigid_result = slam.RigidAnalysis(ground_motion, 0.2)`\n:::\n\n## Flexible sliding block analysis\n\nThe flexible block analyses (decoupled and coupled) require additional input parameters to define the stiffness of the model:\n\n-   `height` - the slope height (in meters, by default)\n-   `vs_slope` - the slope shear wave velocity (in meters per second, by default)\n-   `vs_base` - the base shear wave velocity (in meters per second, by default)\n-   `damp_ratio` - the slope damping ratio\n-   `ref_strain` - the slope reference strain\n-   `soil_model` - the dynamic analysis method used (either `linear_elastic` or `equivalent_linear`)\n\nThese parameters are stored in a dictionary (`flexible_inputs`) and used as kwargs along with those used in the rigid analysis. The decoupled and coupled analyses are run with the `Decoupled` and `Coupled` methods, respectively.\n\n::: {#9955cc14 .cell execution_count=4}\n``` {.python .cell-code}\nflexible_inputs = {\n    \"height\": 50.0,\n    \"vs_slope\": 600.0,\n    \"vs_base\": 600.0,\n    \"damp_ratio\": 0.05,\n    \"ref_strain\": 0.0005,\n    \"soil_model\": \"equivalent_linear\"\n}\n\ndecoupled_result = slam.Decoupled(**rigid_inputs,**flexible_inputs)\ndecoupled_result._compile_attributes()\ncoupled_result = slam.Coupled(**rigid_inputs,**flexible_inputs)\ncoupled_result._compile_attributes()\n```\n:::\n\n\n## Comparison of analysis methods\n\nA simple plot comparing the block displacements with time can be generated by accessing the `.sliding_disp` attribute of each analysis result.\n\n::: {#925a5b54 .cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\n# Some extra stuff to make the p\n```\n:::\n\n\n::: {#cell-fig-comb .cell execution_count=6}\n``` {.python .cell-code}\nplt.figure(figsize=(10, 6))\n\ntime = np.arange(0, len(gm.accel) * gm.dt, gm.dt)\n\n# Plot block displacement vs time for each analysis method\nplt.plot(time, rigid_result.sliding_disp, label='Rigid Analysis')\nplt.plot(time, decoupled_result.sliding_disp, label='Decoupled Analysis')\nplt.plot(time, coupled_result.sliding_disp, label='Coupled Analysis')\n\nsummary_text = f\"ky: {rigid_result.ky / slam.G_EARTH:.2f}g | Motion: {rigid_result.motion_name} (PGA: {max(abs(rigid_result.a_in)):.2f}g)\"\nplt.suptitle(summary_text, fontsize=10, y=0.98)\n\n# Add labels and legend\nplt.xlabel('Time (s)')\nplt.ylabel('Block Displacement (m)')\n# plt.title(f'Block Displacement with Different Analysis Methods\\n for {record_name}')\nplt.legend()\nplt.grid(True)\n\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Block Displacement with Different Analysis Methods](rigid_flex_files/figure-html/fig-comb-output-1.png){#fig-comb width=812 height=561}\n:::\n:::\n\n\n## Inherited plotting\nSince all of these are instances of classes that have `SlidingBlockAnalysis` as their parent class, they all inherit the  `SlidingBlockAnalysis.sliding_block_plot` method.\nCalling the plotting method on each result object produces a concise plot of the analysis.\nBy inspection of the @fig-comb, we can see that all the sliding occurs in the first 10 seconds or so of this particular analysis.\nThe plotting method accepts an optional parameter to focus on the time range of interest which will help show some of the differences in the analysis methods.\n\nWhen we call `sliding_block_plot()` from `rigid_result`, the plot shows the familiar features of a traditional \"Newmark-like\" sliding block analysis.\n\n::: {#cell-fig-rigid .cell execution_count=7}\n``` {.python .cell-code}\ntimes = [0,15]\nrigid_fig = rigid_result.sliding_block_plot(time_range=times)\n```\n\n::: {.cell-output .cell-output-display}\n![Result of calling the `sliding_block_plot()` method on the rigid analysis result.](rigid_flex_files/figure-html/fig-rigid-output-1.png){#fig-rigid width=661 height=474}\n:::\n:::\n\n\nWith the decoupled results, the `sliding_block_plot()` method automatically recognizes the need to display the input motion and the \"base\" motion as separate arrays. \nThe input acceleration is the motion *before* the dynamic response of the slope was calculated.\nThe \"base\" acceleration is the acceleration of the ground beneath the sliding block, which is an output of the slope dynamic response calculation.\nIf we ignore the input acceleration, the base and block acceleration signals look exactly like a rigid analysis result (which is expected because the second half of the decoupled analysis uses rigid sliding assumptions).\n\n::: {#cell-fig-decoupled .cell execution_count=8}\n``` {.python .cell-code}\ndecoupled_fig = decoupled_result.sliding_block_plot(time_range=times)\n```\n\n::: {.cell-output .cell-output-display}\n![Result of calling the `sliding_block_plot()` method on the decoupled analysis result.](rigid_flex_files/figure-html/fig-decoupled-output-1.png){#fig-decoupled width=661 height=474}\n:::\n:::\n\n\nWith the coupled result, we see the differences from the decoupled analysis assumption manifested in the acceleration signals.\nFirst, the block acceleration signal no longer shows the distinct plateau of the yield acceleration during sliding events.\nThis is because the dynamic response of the sliding mass continues to be calculated during sliding and the \"block acceleration\" signal is showing the average acceleration of the whole mass rather than the acceleration at the sliding interface.\nSecond, the base acceleration signal is different than that of the decoupled analysis method during (and very shortly after) sliding because the dynamic response of the slope *beneath* the failure surface is also affected by sliding.\nIn fact, a close inspection of the stop of sliding times reveals an abrupt jump in the base acceleration as the two masses above and below the sliding surface affect each others' dynamic response.\n\n::: {#cell-fig-coupled .cell execution_count=9}\n``` {.python .cell-code}\ncoupled_fig = coupled_result.sliding_block_plot(time_range=times)\n```\n\n::: {.cell-output .cell-output-display}\n![Result of calling the `sliding_block_plot()` method on the coupled analysis result.](rigid_flex_files/figure-html/fig-coupled-output-1.png){#fig-coupled width=661 height=474}\n:::\n:::\n\n\n",
    "supporting": [
      "rigid_flex_files"
    ],
    "filters": [],
    "includes": {}
  }
}